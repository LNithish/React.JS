React is component driven development.
React uses declarative extension to the javascript language called JSX.
React uses clever architectural design known as virtual DOM.
Uses Babel compiler to convert JSX to pure JavaScript.

React build by facebook. used to build components based user interface.
These component have their own life cycle and state.
simple components comes together to make more complex components/UI.
helps in building reusable, stateful and interactive components easily and easy to maintain.
components should be well designed and should have single responsibility.

REACT FEATURES:
Encapsulated components manage their own states. Doesnt need to worry about internal state of other components.
extreme performance.
Generally DOM updates and rerendering are what makes slow. React Doesnt directly interact with DOM of the browser.
Instead React under the hood has virtual representation of DOM. Which is then reconciled with the actual DOM.
These reconciliation process ensures that only those DOM nodes that have actually changed are re-rendered or updated in actual DOM.
The process where the virtual DOM is compared with actual DOM to see whether any changes have to be applied to actual DOM is called reconciliation process.
This virtual DOM is a in memory copy of the DOM that your browser displays.
server side rendering is supported using node and simply display the static page in the site. Virtual DOM helps in enable this.
communication within react application follows very strict direction of flow of data. 
communication using one way data flow. Data flows from top level compoenet to low level component.
React will re-render or change the component based on the state of the data
code is predictable, robust, and easy to debug.

JSX:
React.CreateElement and ReactDOM.Render is tedious to use.
That is why you'll use an HTML like syntax to define your HTML content, it is called JSX.
JSX stands for Javascript syntax extension. 
With JSX you can define user define tags/HTML lile elements. It is user defined compoenets.
JSX allows you to write HTML code inside the JavaScript.

BABEL COMPILER:
It converts JSX into pure Javascript which browser can understand.
during development it converts on the fly.
during production need to precompile for avoiding performance impact.
A function can return both javascript data types and also a React.JSX.elements

PROPS and STATE:
There are two ways to pass data to React component.(props and state)
Props refers to the data that you pass in from the rest of the application toa component so that the component can use that data to display itself.
State is data that is internal to a component.
PROPS are initialization data passed from parent compoenet to child compoenet.
props are considered to be read-only.The data that is present within props should not be changed by the component.
To pass default props we can use defaultProps attribute like classname.defaultProps={Props details}.
propTypes is an attribute in class component to define the type of prop.
There is a specific prop called children passed automatically within this.prop.children, No need to pass any value for this prop.
children prop allows the component to access the child elements of that compoenet.

Every React component is actually a state machine and has internal state held within itself.
This is private data that is internal to the component.Components which hold state are called stateful components.
Data that is private or internal to a component is stored in the state of a component.
This is not data that is passed in from outside,this is data that belongs to a component
state should never be modified directly,otherwise component re-rendering will not occur and your components
State is stored in a special property called state which is accessible within the constructor using this.state.
Each time you update the state component will re render automatically by the react library.

Higher level components should calculate and manage state.And they should pass down data to lower level components using props.
Components have to be re-rendered if their props change or their state change.

EVENTS:
user interactions like click or typing is communicated to our app using Events.
Events in your browser are communicated between the nodes in yourDOM hierarchy in two phases, the capture phase and the bubble phase.
events can be fired by any element in your DOM hierarchy, any node.
There are two ways in which events can travel.The two ways are called event capturing and event bubbling.
When an event is propagated downwards down your html tree structure,that's referred to as event capturing.
This click is propagated upwards, andparent elements of the element p get a chance to react to that event.This is referred to as event bubbling.When a event bubbles upwards to the parent elements.
Browsers use both event capturing as well as event.
React by default handles events in the bubblephase when the event travels upwards to parent elements
If you want events to be handled in the capture phase,you'll use the capture suffix on your event handlers.Instead of onClick, you'll specify onClickCapture.Instead of onMouseOver, you will specify onMouseOverCapture.
event example: mouse event, touch event, click event, keyboard event, selection event, image event, etc ...

We have different types of events with different event objects, and you have different browsers that have different event interfaces.
All of these are brought together behind a single synthetic event.
A synthetic event is an object created within React.React wraps the different event typesin the native browser into a single synthetic event object.
So all you're doing when working in React is working with a single interface,that of the synthetic event you're not worried about the differencesbetween the different types of events.
Synthetic events also help eliminate cross browser differences.So if different browsers have different objects to represent different typesof events, well, you don't have to care about them at all.
You don't have to worry about whether a certain property exists on Chrome whether it exists on Firefox and so on.
Also, common functions available on event objects, such as stopPropogation()and preventDefault(), are available on the synthetic event as well.
stopPropogation() is what you'd invoke when you want to stop the propagationof this event beyond the current event handler.And preventDefault() is what you'll invokewhen you want to prevent the browser's default handling of the event.
There is another advantage to having synthetic event trappers in a React andthat is event pooling.Event pooling is when you reuse the synthetic event wrapper formultiple events to improve the performance of your application. handled by React automatically.

Components have a life cycle divided into phases.

MOUNTING:
We first have the mounting phase,when the component is first rendered into the DOM.This is the phase where the component is initialized and rendered forthe first time.
The first function within your React component that is called in the mounting phase is the constructor of your component.
This is where you initialize the state of your component.Once the constructor has been called, the render function is invokedto render the component into your DOM to display the component to screen.
Once the render function finishes executing, React is in charge of updatingthe DOM, or the Document Object Model of your browser, andany references to your components.
Do not update state inside render function it will cause the component to be re-render again and again.
And the special method that is invoked at the end of this mounting phase, is componentDidMount.

UPDATING:
We then have the updating phase of the component,which the component gets into when its state changes.Changes in state of the component causes the component to update itself,that is the updating phase.
A component moves into the updating phase under certain conditions.It receives new props from its parent element.setState() has been invoked andthe internal state associated with the component has changed.Or you've caused the component to forceUpdate().
And in the update phase, the render function is invoked once again.The component is re-rendered.Once the re-rendering is complete and the component has been updated,the special method that is then invoked is componentDidUpdate.

UNMOUNTING:
And finally, when a component is removed from the DOM,that is the unmounting phase of the component.These are the three phases in the component's life cycle.
the last phase in the components life cycle is the unmounting phase.This is when a component is about to be removed from the DOM,it's no longer needed.That's when, just before the component is removed from the DOM,componentWillUnmount is called.

DOM reconciliation:
changes made first applied in virtual DOM and then applied in actual DOM after reconciliation process.

ERROR BOUNDARY:
The componentDidCatch can be thought of as a part of the lifecycle methods of a component.
It's an error boundary that is invoked when any component in the component tree nested under the StreamingNumbers component throws an error.This is the error boundary.
Anywhere in the component tree,if an error occurs, you don't have to worry about where it will be handled.The error will be propagated up the component tree to the closest error boundary.
The standard way to use an error boundary is to have just one component be the error boundary.
So you write code once for errors on your page, and you handle all of the errors there.
The same error boundary component is thus reusable for all components in your component tree.

FORMS:

in React, forms are still special because formstypically hold some internal state of their own.
component have the ability to manage their own state.And the state of components need to be synced up with the internal data held by forms, displayed within components.
And this is exactly why forms in React are often set up as controlled components.

CONTROLLED COMPONENTS:
When you sync up the state object with the internal data held in form elements and use React to control the state of the form, that is a controlled component.
You're controlling form elements using the React components' state,that is a controlled component.

REF:
We can use ref to access DOM nodes or react elements that have been created within the render method of component.
This is needed when working with uncontrolled component.

THIS.PROPS.CHILDREN:
In React, this.props.children is a special prop that allows components to accept and render content passed between their opening and closing tags. 
It enables the creation of highly reusable and flexible components, often referred to as "wrapper" or "layout" components
